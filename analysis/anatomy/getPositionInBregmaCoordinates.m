function p=getPositionInBregmaCoordinates(eventdata,which,levelToTopOfBrain,nonPresentValue)
% eventdata- as generated by physiologySever event logger
% which - a logical (or index) into which events

if ~exist('levelToTopOfBrain','var') || isempty(levelToTopOfBrain)
    levelToTopOfBrain=false;
    
end

if ~exist('nonPresentValue','var') || isempty(nonPresentValue)
    %nonPresentValue=1; % would floast the data above the brain, so you see it
    nonPresentValue=nan;
end

raw_position=vertcat(eventdata(which).position);
surgeryA=vertcat(eventdata(which).surgeryAnchor);
surgeryB=vertcat(eventdata(which).surgeryBregma);
A=vertcat(eventdata(which).currentAnchor);

%get translation from surgery
translation=surgeryB-surgeryA;  % distance to surgery anchor from bregma
translation(:,1)=-abs(translation(:,1)); %enforce anchor is posterior to bregma
translation(:,2)=-abs(translation(:,2)); %enforce anchor is to the left of bregma

% calculate current position
current_offset=(raw_position-A); % distance to current anchor from current position
%convert from rig1's inverted position (posterior positive; left postive) to matlabs axis (anterior positive; right positive)
current_offset(:,1)=-current_offset(:,1); % flip AP
current_offset(:,2)=-current_offset(:,2); % flipML

p=current_offset+translation;  % in rig one larger number are posterior

if levelToTopOfBrain
    % this has the dangerous effect of ignoring brain curvature
    % or doing some strange normalization with respect to
    % cortical surface bulging...
    % but can be used to clean up data with "messy z"
    % if every penetration reliably has a "top of brain event"
    
    % set the top at -0.7mm (paxinos and watson, ctx surface relative to bregma, roughly above LGN)
    newTOB=-0.7;
    
    %find TOB z value reading for each penetration (called 'TOBraw')
    allPenIDs=find(~cellfun('isempty',{eventdata.penetrationNum}));
    TOB=ismember({eventdata.eventType},{'top of brain'});
    pen=[eventdata.penetrationNum];
    pens=unique(pen);
    TOBraw=nan(1,length(pens));
    for i=1:length(pens)
        %find the TOB for this penetration
        thisPen=[eventdata.penetrationNum]==pens(i);
        if length(thisPen)~=length(allPenIDs)
            error('expected to be the same... violates logic if not')
        end
        thisTOB=ismember({eventdata(allPenIDs(thisPen)).eventType},{'top of brain'});
        thisTOF=ismember({eventdata(allPenIDs(thisPen)).eventType},{'top of fluid'}); % not used currently!
        if any(thisTOB)  % if there is a top of brain this penetration, then
            TOBIndLocal=max(find(thisTOB)); %use the last observation if many this penetration
            eventIDsThisPen=find(thisPen);
            TOBIndGlobal=allPenIDs(eventIDsThisPen(TOBIndLocal));
            TOBraw(i)=eventdata(TOBIndGlobal).position(1,3); % save it for the next calculation
        end
    end
    
    %find TOB for each event that will be plotted
    positionsToChange=find(which & ~cellfun('isempty',{eventdata.penetrationNum}));
    TOBforEachEvent=TOBraw([eventdata(positionsToChange).penetrationNum]);
    
    
    for i=1:length(positionsToChange)
        if isnan(TOBforEachEvent(i))
            p(i,3)=nonPresentValue+rand/2;
            %data with out "top of brain event, can be placed
            %above the brain, with some scatter, but is nan'd by default
        else
            p(i,3)= eventdata(positionsToChange(i)).position(1,3)-TOBforEachEvent(i)+newTOB;
        end
    end
end